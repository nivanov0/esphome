substitutions:
  name: underfloor-power-meter-e81c3c
  cutoff_dt: 1.0f
esphome:
  name: ${name}
  friendly_name: Underfloor Power Meter e81c3c
  name_add_mac_suffix: false
  project:
    name: nivanov0.underfloor_power_meter
    version: 1.0.1

esp32:
  board: esp32-c6-devkitm-1
  variant: esp32c6
  framework:
    type: esp-idf

preferences:
  flash_write_interval: 15min

status_led:
  pin:
    number: GPIO23
wifi:
  ap:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: !secret underfloor-power-meter-e81c3c_address

improv_serial:
esp32_improv:
  authorizer: none
  status_indicator: led_blue
api:
  reboot_timeout: 0s
  encryption:
    key: !secret underfloor-power-meter-e81c3c

logger:
  level: INFO
ota:
  platform: esphome

captive_portal:
time:
- platform: sntp
  id: sntp_time

web_server:
  ota: false
  local: true

button:
- platform: factory_reset
  name: Restart with Factory Default Settings

sensor:
- platform: wifi_signal   # Reports the WiFi signal strength/RSSI in dB
  name: WiFi Signal dB
  id: wifi_signal_db
  update_interval: 60s
  entity_category: diagnostic

- platform: copy   # Reports the WiFi signal strength in %
  source_id: wifi_signal_db
  name: WiFi Signal Percent
  filters:
  - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
  unit_of_measurement: '%'
  entity_category: diagnostic

- platform: pulse_counter
  id: flow_lpm
  name: Flow
  pin:
    number: GPIO7
    mode:
      input: true
      pullup: true
  update_interval: 5s
  unit_of_measurement: L/min
  accuracy_decimals: 2
  device_class: volume_flow_rate
  state_class: measurement
  filters:
  - lambda: |-
      const float pulses_per_min = x;
      float q = (pulses_per_min + 240.0f) / 480.0f;  // L/min
      if (q < 0.2f) q = 0.0f;
      return q;
# ===================== NTC1 (Supply): IO1 =====================
- platform: adc
  id: adc_supply
  pin: GPIO1
  update_interval: 2s
  internal: true
  attenuation: 12db
  filters:
    - median:
        window_size: 3
        send_every: 4
        send_first_at: 3
  

- platform: resistance
  id: r_supply
  sensor: adc_supply
  configuration: DOWNSTREAM
  resistor: 4.7kOhm

- platform: ntc
  id: t_supply
  name: Supply Temp
  sensor: r_supply
  calibration:
    - 11835.2Ohm -> 20.7°C
    - 7503Ohm -> 29.7°C
    - 7023.35Ohm -> 30.9°C
#    b_constant: 3950
#    reference_temperature: 25°C
#    reference_resistance: 10kOhm

  unit_of_measurement: °C
  device_class: temperature
  state_class: measurement

# ===================== NTC2 (Return): IO5 =====================
- platform: adc
  id: adc_return
  pin: GPIO5
  update_interval: 2s
  internal: true
  attenuation: 12db
  filters:
    - median:
        window_size: 3
        send_every: 4
        send_first_at: 3


- platform: resistance
  id: r_return
  sensor: adc_return
  configuration: DOWNSTREAM
  resistor: 4.7kOhm

- platform: ntc
  id: t_return
  name: Return Temp
  sensor: r_return
  calibration:
    - 12400.3Ohm -> 20.7°C
    - 8810.5Ohm -> 29.7°C
    - 8410.7Ohm -> 30.7°C
#    b_constant: 3950
#    reference_temperature: 25°C
#    reference_resistance: 10kOhm
    
  unit_of_measurement: °C
  device_class: temperature
  state_class: measurement

- platform: template
  id: delta_t
  name: ΔT
  unit_of_measurement: °C
  accuracy_decimals: 2
  update_interval: 5s
  device_class: temperature
  state_class: measurement
  lambda: |-
    if (isnan(id(tp_load_in).state) || isnan(id(tp_load_out).state)) return NAN;
    return id(tp_load_out).state - id(tp_load_in).state;

# ===================== Power =====================
- platform: template
  id: heat_power_w
  name: Heat Power
  unit_of_measurement: W
  accuracy_decimals: 0
  update_interval: 5s
  device_class: power
  state_class: measurement
  lambda: |-
    float dT = id(delta_t).state;
    float lpm = id(flow_lpm).state;
    const float rc  = 4184.0f;  // J/L·°C

    if (isnan(dT) || isnan(lpm)) return NAN;
    if (fabsf(dT) < ${cutoff_dt}) return 0.0f;

    float lps = lpm / 60.0f;      // L/min -> L/s
    return dT * lps * rc;

# ===================== Consumption =====================
- platform: integration
  id: tp_heat_energy_wh
  name: TP Heat Energy (Wh)
  sensor: heat_power_w
  time_unit: h
  unit_of_measurement: Wh
  accuracy_decimals: 2
  device_class: energy
  state_class: total_increasing
  restore: true
  internal: true

- platform: template
  name: TP Heat Energy (kWh)
  unit_of_measurement: kWh
  accuracy_decimals: 3
  device_class: energy
  state_class: total_increasing
  lambda: |-
    if (isnan(id(tp_heat_energy_wh).state)) return NAN;
    return id(tp_heat_energy_wh).state / 1000.0f;

- platform: homeassistant
  entity_id: sensor.s3em_tp_total_active_power
  name: 3EM-TP power
  id: power_elec_w
  internal: true
  unit_of_measurement: W
  device_class: power
  state_class: measurement

- platform: homeassistant
  entity_id: sensor.wellin
  name: TP Load in temperature
  id: tp_load_in
  internal: false
  unit_of_measurement: °C
  device_class: power
  state_class: measurement


- platform: homeassistant
  entity_id: sensor.loadout
  name: TP Load out temperature
  id: tp_load_out
  internal: false
  unit_of_measurement: °C
  device_class: power
  state_class: measurement
  
  


- platform: template
  id: cop_instant
  name: "COP Instant"
  unit_of_measurement: ""
  accuracy_decimals: 2
  update_interval: 5s
  state_class: total
  lambda: |-
    float pe = id(power_elec_w).state;
    float ph = id(heat_power_w).state;
    // режем нереални стойности при спиране/старт
    if (pe <= 0.0f || ph <= 0.0f) {
      return 0.0f;
    }
    return ph / pe;

- platform: total_daily_energy
  name: "TP Electric Energy Today (KWh)"
  id: tp_elec_energy_today_kwh
  power_id: power_elec_w
  unit_of_measurement: Kwh
  filters:
    - multiply: 0.001     # W → kW
  accuracy_decimals: 3
  device_class: energy
  state_class: total_increasing

- platform: template
  id: cop_today
  name: "COP Today"
  unit_of_measurement: ""
  accuracy_decimals: 2
  update_interval: 60s
  state_class: total
  lambda: |-
    float e_heat = id(tp_heat_energy_today_kwh).state;
    float e_elec = id(tp_elec_energy_today_kwh).state;

    if (isnan(e_heat) || isnan(e_elec) || e_elec <= 0.0f) {
      return 0.0f;
    }

    return e_heat / e_elec;

- platform: total_daily_energy
  name: "TP Heat Energy Today (kWh)"
  id: tp_heat_energy_today_kwh
  power_id: heat_power_w
  filters:
    - multiply: 0.001     # W → kW
  unit_of_measurement: kWh
  accuracy_decimals: 3
  device_class: energy
  state_class: total_increasing

# ===================== State =====================
binary_sensor:
- platform: template
  name: Flow Present
  lambda: |-
    return (!isnan(id(flow_lpm).state) && id(flow_lpm).state > 0.2f);

text_sensor:
- platform: template
  name: Local Time
  id: local_time_str
  icon: mdi:clock
  lambda: |-
    auto time = id(sntp_time).now();
    if (!time.is_valid()) return {"Time not synced"};
    char buffer[20];
    snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d", time.hour, time.minute, time.second);
    return {buffer};
  update_interval: 10s

- platform: wifi_info
  ip_address:
    name: ESP IP Address

  ssid:
    name: ESP Connected SSID

  mac_address:
    name: ESP Mac Wifi Address
- platform: template
  name: Heatmeter Status
  lambda: |-
    if (isnan(id(t_supply).state) || isnan(id(t_return).state)) return {"No temp"};
    if (isnan(id(flow_lpm).state)) return {"No flow"};
    if (id(flow_lpm).state < 0.2f) return {"Flow too low"};
    return {"OK"};
output:
- platform: gpio
  id: led_blue
  pin: GPIO22

